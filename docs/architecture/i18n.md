# Internationalization (i18n) System

## Overview

The `cldev` CLI tool includes a comprehensive internationalization (i18n) system that supports multiple languages with automatic language detection and message formatting with variable substitution.

## Features

### Supported Languages

- **English** (en) - Default language
- **Japanese** (ja) - Full translation support

### Automatic Language Detection

The system automatically detects the user's preferred language from environment variables:
1. `LANG` environment variable (primary)
2. `LC_ALL` environment variable (fallback)
3. English (default fallback)

### Variable Substitution

Messages can include placeholders in the format `{variable_name}` which are replaced at runtime:

```rust
let i18n = I18n::new();
let msg = i18n.format("next-step", "command", "cldev config check");
// English: "üí° Next step: cldev config check"
// Japanese: "üí° Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó: cldev config check"
```

### Fallback Mechanism

The system implements a robust fallback chain:
1. Try the current language
2. Fallback to English if translation is missing
3. Return the key itself if no translation exists

## Architecture

### Core Components

1. **Language** - Enum representing supported languages
2. **MessageCatalog** - Container for all translations
3. **I18n** - Main internationalization handler
4. **OutputHandler** - Integration with CLI output system

### File Structure

```
src/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îî‚îÄ‚îÄ i18n.rs           # Core i18n implementation
‚îú‚îÄ‚îÄ i18n/
‚îÇ   ‚îî‚îÄ‚îÄ messages.json     # Translation database
‚îî‚îÄ‚îÄ cli/
    ‚îî‚îÄ‚îÄ output.rs         # OutputHandler with i18n integration
```

## Usage

### Basic Message Retrieval

```rust
use cldev::core::i18n::I18n;

let i18n = I18n::new();
let msg = i18n.get("command-success");
// Returns: "Command executed successfully" or "„Ç≥„Éû„É≥„ÉâÂÆüË°åÊàêÂäü"
```

### Single Variable Substitution

```rust
let msg = i18n.format("next-step", "command", "cldev config check");
```

### Multiple Variable Substitution

```rust
use std::collections::HashMap;

let mut vars = HashMap::new();
vars.insert("current", "1");
vars.insert("total", "5");
let msg = i18n.get_with_vars("step", &vars);
// Returns: "Step 1/5" or "„Çπ„ÉÜ„ÉÉ„Éó 1/5"
```

### Integration with OutputHandler

```rust
use cldev::cli::output::OutputHandler;

let output = OutputHandler::new(false, false, false);

// Get localized message
output.success(&output.t("config-check-success"));

// Get localized message with variable
output.info(&output.t_format("next-step", "command", "cldev config init"));

// Get localized message with multiple variables
let mut vars = HashMap::new();
vars.insert("field", "timeout");
vars.insert("value", "invalid");
output.error(&output.t_with_vars("invalid-value", &vars));
```

### Language Selection

```rust
use cldev::core::i18n::{I18n, Language};

// Automatic detection
let i18n = I18n::new();

// Explicit language
let i18n = I18n::with_language(Language::Japanese);

// Dynamic switching
let mut i18n = I18n::new();
i18n.set_language(Language::Japanese);
```

## Message Catalog

The message catalog is stored in JSON format at `src/i18n/messages.json`:

```json
{
  "en": {
    "command-success": "Command executed successfully",
    "next-step": "üí° Next step: {command}"
  },
  "ja": {
    "command-success": "„Ç≥„Éû„É≥„ÉâÂÆüË°åÊàêÂäü",
    "next-step": "üí° Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó: {command}"
  }
}
```

### Message Categories

The catalog includes messages for:

- **Command execution** - Success/failure messages
- **Configuration** - Config management messages
- **File operations** - File I/O related messages
- **Validation** - Validation result messages
- **UI elements** - Common UI text (yes/no, confirm/cancel, etc.)
- **Progress indicators** - Loading, saving, completion messages

### Available Message Keys

#### Command Execution
- `command-success` - Command executed successfully
- `command-failed` - Command execution failed

#### Configuration
- `config-check-success` - Configuration file is valid
- `config-check-failed` - Configuration file has errors
- `config-init-success` - Configuration initialized
- `config-init-failed` - Failed to initialize configuration
- `config-already-exists` - Configuration file already exists
- `config-edit-opening` - Opening configuration file for editing
- `config-edit-failed` - Failed to open configuration file
- `config-created-at` - Configuration created at: {path}

#### General
- `next-step` - Next step: {command}
- `use-force-to-overwrite` - Use --force to overwrite
- `creating-default-config` - Creating default configuration...
- `validating-config` - Validating configuration...

#### Validation
- `validation-passed` - Validation passed
- `validation-failed` - Validation failed with {count} error(s)

#### File Operations
- `file-not-found` - File not found: {path}
- `file-read-error` - Failed to read file: {path}
- `file-write-error` - Failed to write file: {path}
- `permission-denied` - Permission denied: {path}

#### Errors
- `invalid-format` - Invalid format: {details}
- `parsing-error` - Parsing error: {error}
- `missing-required-field` - Missing required field: {field}
- `invalid-value` - Invalid value for {field}: {value}

#### UI Elements
- `success`, `error`, `warning`, `info`, `debug`
- `yes`, `no`, `confirm`, `cancel`, `continue`, `abort`, `retry`, `skip`
- `help`, `version`, `usage`, `examples`, `options`, `arguments`
- `commands`, `subcommands`, `aliases`
- `description`, `details`, `summary`

#### Progress
- `step` - Step {current}/{total}
- `operation-in-progress` - Operation in progress...
- `operation-completed` - Operation completed
- `operation-failed` - Operation failed
- `loading` - Loading...
- `saving` - Saving...
- `done` - Done
- `cancelled` - Cancelled

## Adding New Messages

1. Add the message key and text to `src/i18n/messages.json`:

```json
{
  "en": {
    "new-message": "New message with {variable}"
  },
  "ja": {
    "new-message": "Êñ∞„Åó„ÅÑ„É°„ÉÉ„Çª„Éº„Ç∏ {variable}"
  }
}
```

2. Use the message in code:

```rust
let msg = i18n.format("new-message", "variable", "value");
output.info(&output.t_format("new-message", "variable", "value"));
```

## Adding New Languages

1. Add language variant to `src/core/i18n.rs`:

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Language {
    English,
    Japanese,
    French,  // New language
}
```

2. Update detection logic:

```rust
pub fn detect() -> Self {
    if let Ok(lang) = env::var("LANG") {
        let lang_lower = lang.to_lowercase();
        if lang_lower.starts_with("ja") {
            return Language::Japanese;
        } else if lang_lower.starts_with("fr") {
            return Language::French;
        }
    }
    Language::English
}
```

3. Add translations to `messages.json`:

```json
{
  "en": { ... },
  "ja": { ... },
  "fr": {
    "command-success": "Commande ex√©cut√©e avec succ√®s"
  }
}
```

## Testing

### Unit Tests

The i18n system includes comprehensive unit tests:

```bash
cargo test --lib i18n
```

Tests cover:
- Language detection and code parsing
- Message catalog loading and retrieval
- Variable substitution (single and multiple)
- Fallback behavior
- Language switching

### Integration Testing

Run the demo program to see all features in action:

```bash
cargo run --example i18n_demo
```

### Manual Testing

Test different languages by setting the `LANG` environment variable:

```bash
# English
LANG=en_US.UTF-8 cargo run -- config check

# Japanese
LANG=ja_JP.UTF-8 cargo run -- config check
```

## Performance Considerations

1. **Embedded Messages** - The default message catalog is embedded in the binary using `include_str!()`, avoiding runtime file I/O
2. **Minimal Overhead** - Message lookup is O(1) using HashMap
3. **String Allocation** - Variable substitution allocates new strings only when needed
4. **Language Detection** - Performed once at initialization

## Best Practices

1. **Use Descriptive Keys** - Use kebab-case keys like `config-check-success`
2. **Include Context** - Message keys should indicate their context
3. **Consistent Variables** - Use consistent variable names across messages
4. **Fallback Safety** - Always provide English fallback translations
5. **Test Translations** - Verify translations with native speakers
6. **Avoid Hardcoding** - Never hardcode user-facing strings

## Examples

See the complete example in `examples/i18n_demo.rs`:

```bash
cargo run --example i18n_demo
```

This demonstrates:
- Automatic language detection
- Explicit language selection
- Variable substitution
- OutputHandler integration
- Fallback behavior
- Language switching

## Troubleshooting

### Messages Not Translating

1. Check `LANG` environment variable: `echo $LANG`
2. Verify message key exists in `messages.json`
3. Ensure JSON syntax is valid: `cargo test --lib i18n`

### Variable Not Substituted

1. Check variable name matches placeholder: `{variable_name}`
2. Ensure variable is passed in HashMap
3. Verify no typos in variable names

### Language Not Detected

1. Set `LANG` environment variable explicitly
2. Use `I18n::with_language()` for explicit control
3. Check language detection logic in `Language::detect()`

## Future Enhancements

Planned improvements for the i18n system:

- [ ] Support for plural forms
- [ ] Date/time formatting
- [ ] Number formatting (thousands separators, decimals)
- [ ] Currency formatting
- [ ] Right-to-left (RTL) language support
- [ ] External translation files for user customization
- [ ] Translation validation tools
- [ ] Crowdin/Transifex integration
- [ ] Context-aware translations
- [ ] Gender-specific translations
